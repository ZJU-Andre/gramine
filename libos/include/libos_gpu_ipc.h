// SPDX-License-Identifier: GPL-3.0-only OR BSD-3-Clause
/*
 * Copyright (C) 2023 Gramine contributors
 *
 * This file is part of the Gramine project.
 */

#ifndef LIBOS_GPU_IPC_H
#define LIBOS_GPU_IPC_H

#include <stdint.h>
#include <stddef.h> // For size_t

// Maximum length for kernel names
#define MAX_KERNEL_NAME_LEN 256
// Maximum length for serialized kernel arguments. Adjust as needed.
#define MAX_KERNEL_ARGS_SERIALIZED_LEN 1024
// Maximum length for shared memory path
#define MAX_SHM_PATH_LEN 256


/**
 * @brief Defines the types of commands that can be sent between the enclave and the CUDA proxy.
 */
typedef enum {
    CMD_INIT = 0,       /**< Initial handshake, potentially passing SHM info or session keys. */
    CMD_MALLOC_DEVICE,  /**< Request to allocate CUDA device memory. */
    CMD_FREE_DEVICE,    /**< Request to free previously allocated CUDA device memory. */
    CMD_MEMCPY_H2D,     /**< Request to copy memory from host (enclave's SHM) to device. */
    CMD_MEMCPY_D2H,     /**< Request to copy memory from device to host (enclave's SHM). */
    CMD_LAUNCH_KERNEL,  /**< Request to launch a CUDA kernel. */
    CMD_SHUTDOWN        /**< Notification to the proxy to clean up and exit. */
} gpu_command_type_t;

/**
 * @brief Generic message header for all IPC communication between enclave and proxy.
 */
typedef struct {
    gpu_command_type_t type;   /**< Type of the command or response. */
    uint32_t payload_size; /**< Size of the specific command/response data following this header. */
    int32_t status;        /**< Status code for responses from proxy to enclave (e.g., 0 for success, negative for error). */
} gpu_message_header_t;


// --- CMD_INIT ---
/** @brief Request payload for CMD_INIT. Sent from enclave to proxy. */
typedef struct {
    uint8_t session_key[32];         /**< For AES-256 key, generated by enclave. */
    char shm_path[MAX_SHM_PATH_LEN]; /**< Path/identifier for the shared memory region. */
    size_t shm_size;                 /**< Total size of the shared memory region. */
    // Potentially other initialization data.
} cmd_init_req_t;

/** @brief Response payload for CMD_INIT. Sent from proxy to enclave. */
typedef struct {
    // Potential fields: proxy capabilities, confirmation of SHM mapping etc.
    // For now, can be empty, status in header is primary.
    int32_t proxy_status_report; /**< Example field: Proxy's self-report on initialization. */
} cmd_init_resp_t;


// --- CMD_MALLOC_DEVICE ---
/** @brief Request payload for CMD_MALLOC_DEVICE. Sent from enclave to proxy. */
typedef struct {
    size_t size; /**< Size of the device memory to allocate, in bytes. */
} cmd_malloc_device_req_t;

/** @brief Response payload for CMD_MALLOC_DEVICE. Sent from proxy to enclave. */
typedef struct {
    uint64_t device_ptr_opaque; /**< Opaque handle representing the allocated device memory.
                                     The actual CUdeviceptr value is kept by the proxy. */
} cmd_malloc_device_resp_t;


// --- CMD_FREE_DEVICE ---
/** @brief Request payload for CMD_FREE_DEVICE. Sent from enclave to proxy. */
typedef struct {
    uint64_t device_ptr_opaque; /**< Opaque handle of the device memory to free. */
} cmd_free_device_req_t;
// No specific response payload for CMD_FREE_DEVICE; status in gpu_message_header_t is sufficient.


// --- CMD_MEMCPY_H2D ---
/** @brief Request payload for CMD_MEMCPY_H2D. Sent from enclave to proxy. */
typedef struct {
    uint64_t device_ptr_opaque; /**< Opaque handle of the destination device memory. */
    uint64_t shm_offset;        /**< Offset within the shared memory region where the source data is located. For now, 0. */
    size_t size;                /**< Size of the data to copy, in bytes. */
    uint8_t iv[12];             /**< IV used by enclave to encrypt data in SHM. */
    uint8_t tag[16];            /**< GCM tag from enclave encryption. */
} cmd_memcpy_h2d_req_t;
// No specific response payload for CMD_MEMCPY_H2D; status in gpu_message_header_t is sufficient.


// --- CMD_MEMCPY_D2H ---
/** @brief Request payload for CMD_MEMCPY_D2H. Sent from enclave to proxy. */
typedef struct {
    uint64_t device_ptr_opaque; /**< Opaque handle of the source device memory. */
    uint64_t shm_offset;        /**< Offset within the shared memory region where the data should be placed. For now, 0. */
    size_t size;                /**< Size of the data to copy, in bytes. */
} cmd_memcpy_d2h_req_t;

/** @brief Response payload for CMD_MEMCPY_D2H. Sent from proxy to enclave. */
typedef struct {
    // status is in gpu_message_header_t
    uint8_t iv[12];             /**< IV used by proxy to encrypt data in SHM. */
    uint8_t tag[16];            /**< GCM tag from proxy encryption. */
    size_t actual_size_written_to_shm; /**< Confirmation of data size written by proxy. */
} cmd_memcpy_d2h_resp_t;


// --- CMD_LAUNCH_KERNEL ---
/** @brief Request payload for CMD_LAUNCH_KERNEL. Sent from enclave to proxy. */
typedef struct {
    char kernel_name[MAX_KERNEL_NAME_LEN]; /**< Name of the kernel to launch. */
    unsigned char serialized_args[MAX_SERIALIZED_KERNEL_ARGS_LEN]; /**< Buffer for serialized args. */
    uint32_t serialized_args_len;       /**< Length of actual serialized data in bytes. */
    unsigned int grid_dim_x;            /**< Grid dimension X. */
    unsigned int grid_dim_y;            /**< Grid dimension Y. */
    unsigned int grid_dim_z;            /**< Grid dimension Z. */
    unsigned int block_dim_x;           /**< Block dimension X. */
    unsigned int block_dim_y;           /**< Block dimension Y. */
    unsigned int block_dim_z;           /**< Block dimension Z. */
    unsigned int shared_mem_bytes;      /**< Dynamic shared memory size per block, in bytes. */
    // CUstream stream; // Stream identifier might be complex to pass; for now, assume default stream or managed by proxy.
} cmd_launch_kernel_req_t;
// No specific response payload for CMD_LAUNCH_KERNEL; status in gpu_message_header_t is sufficient.


// --- CMD_SHUTDOWN ---
// No specific request or response payload for CMD_SHUTDOWN.
// The command itself, indicated by gpu_command_type_t in the header, is sufficient.

#endif /* LIBOS_GPU_IPC_H */
